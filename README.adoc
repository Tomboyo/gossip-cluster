= GossipCluster

For Fun And Practice, implement a UDP-multicast clustering mechanism in elixir.

Following in the footsteps of bitwalker's _libcluster_ <<libcluster>> library,
this library uses a gossip (epidemic) protocol <<gossip>> to locate and connect
to other nodes on the network.

Each node starts a UDP socket subscribed to a multicast address. Each node both
sends "heartbeats" to that address and listens for heartbeats from other nodes
on that address. When a node sends a message out, it encodes its own location in
the packet. When a node receives a message, it decodes the peer node's location
and attempts to connect via `Node.connect/1`.

By default, each node listens to an unassigned multicast address in the
ADHOC-III block <<iana>>. This should be of little consequence in the scope of
this exercise, but in any case is unlikely to collide with other applications
running on the network.

This is surprisingly easy to achieve in Elixir. A naive implementation fits
within 60 lines of code. There are many quality-of-life features of elixir and
erlang which make this possible:

* Elixir and Erlang define a GenServer ("generic server") module which we can
  use to define a wide variety of server processes. These define high-level
  APIs frequently driven with pattern-match syntax for handling arbitrary RPC
  messages, where messages are structured data in the process's "mailbox", a
  stack-like structure.
* When we start a UDP socket with `:gen_udp.open/1` <<gen_udp>>, it starts in
  "active" mode by default. When an "active" socket receives a message, it
  marshals that message into the owning process's mailbox. Our GenServer need
  only implement a
  `handle_info({:udp, socket, ip, port, binary_or_list_packet}, state)`
  <<handle_info>> callback to receive data over the network. This is very
  convenient.
* Elixir and erlang implement strings as binaries, which are also bitstrings.
  Elixir and erlang also support high-level pattern-match syntax <<binaries>>
  for operating on bitstrings, which has the convenient effect that
  `<<"heartbeat::" <> node_name::binary>> = packet` is both a guard clause to
  only handle UDP packets starting with a "heartbeat::" UTF-8 sentinel and a
  pattern to extract the binary-encoded node name from the packet. Once we have
  the encoded name, we then parse the binary with
  `:erlang.bytes_to_term(node_name)` and simply `Node.connect/1` to the result!

== Run It

This exercise is shipped with a Dockerfile, so very little work is required to
run. However, special consideration needs to be made if we wish to launch this
application on just one computer, since both gossip-cluster nodes will attempt to
listen on the same socket; only one can succeed. One way around this is to use
minishift, which allows two or more pods to communicate on the same multicast
socket. Another, of course, is to start another laptop. Instructions for both
methods follow.

=== Using Minishift

If you have minishift <<minishift>> installed, the following commands are
sufficient to start two pods gossipping over multicast:

[source, bash]
----
minishift start
eval $(minishift oc-env)
oc new-app . --name=gossip
oc scale --replicas=2 dc gossip
----

To confirm that the nodes are gossipping successfully, use `oc get pods` to
display the names of available pods and `oc logs -f $podname` to stream their
logs. For example:

[source, bash]
----
$ oc get pods
NAME             READY     STATUS      RESTARTS   AGE
gossip-1-6msjw   1/1       Running     0          7s
gossip-1-build   0/1       Completed   0          22s
gossip-1-fgp9d   1/1       Running     0          7s

$ oc logs -f gossip-1-6msjw
00:19:46.712 [debug] Received hearbeat from :"gossip_cluster@gossip-1-6msjw"
00:19:47.039 [debug] Received hearbeat from :"gossip_cluster@gossip-1-fgp9d"
00:19:47.717 [debug] Received hearbeat from :"gossip_cluster@gossip-1-6msjw"
00:19:48.040 [debug] Received hearbeat from :"gossip_cluster@gossip-1-fgp9d"
...
----

=== Using Two Computers

==== Podman or Docker

NOTE: These instructions use podman for building and running the container, but
docker and podman support the same commands, so either should work.

Suppose you have two computers on the same network. On one computer:

[source,bash]
----
podman build --tag gossip .
podman run --net=host -e RELEASE_NAME=a gossip
----

This will begin running the GossipCluster application from a podman container.
On the other computer (note the different release name):

[source,bash]
----
podman build --tag gossip .
podman run --net=host -e RELEASE_NAME=b gossip
----

You should see a NODEUP messages within a few seconds on both computers as they
locate one another over multicast. Failure to assign each node a different
`RELEASE_NAME` may result in an error like
`** Cannot get connection id for node name@host`.

==== Iex

If both computers have elixir installed, you can run the following command on
each (setting the value of `--sname` differently for each computer):

[source,bash]
----
iex --sname a --cookie cookie -S mix
----

[bibliography]
== References
- [[[libcluster, 1]]] https://github.com/bitwalker/libcluster
- [[[gossip, 2]]] https://en.wikipedia.org/wiki/Gossip_protocol
- [[[gen_udp, 3]]] http://erlang.org/doc/man/gen_udp.html#open-1
- [[[handle_info, 4]]] https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2
- [[[binaries, 5]]] https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html
- [[[iana, 6]]] https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xhtml#multicast-addresses-11
- [[[minishift, 7]]] https://www.okd.io/minishift/
